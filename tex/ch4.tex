%   MSc Business Analytics Dissertation
%   Format based on skeleton template provided as part of module MIS40750
%
%   Title:     Optimising the design of buffer preparation in bioprocessing
%              facilities
%   Author:    Sean Tully
%
%   Chapter 4: Methodology
%
%   Change Control:
%   When     Who   Ver  What
%   -------  ----  ---  --------------------------------------------------------
%   06Jun16  ST    0.1  Begun 
%

\chapter{Methodology}\label{C.methodology}

\begin{quote}
Just as the largest library, badly arranged, is not so useful as a very moderate
one that is well arranged, so the greatest amount of knowledge, if not
elaborated by our own thoughts, is worth much less than a far smaller volume
that has been abundantly and repeatedly though over.  For only by universally
combining what we know, by comparing every truth with every other, do we fully
assimilate our own knowledge and get it into our power.

\hspace{2cm}--- Arthur Schopenhauer, \emph{On Thinking for Oneself}
\end{quote}

\section{Introduction}\label{S.intro4}

At first glance, the pathway to solving the vessel selection problem was
unclear.
There are two aspects to the problem; scheduling and selection.  
The selection problem appears to be a close relative of a number of classic 
$\mathcal{NP}$-hard problems in the ``bin-packing'' genre.  
For the scheduling aspect of the problem, initial concepts involved finding an
API to one of the commercial scheduling packages.
One intial concept included developing an algorithm to intelligently guess
possible vessel selections, and pass these into a scheduling model which 
could be repeatedly be solved using a commercial scheduling package
to find an optimium selection.

On completion of the module on linear programming, it became apparent that
many bin-packing type problems are most efficiently solved using linear
programming techniques.
Additionally, linear programming could be used to model scheduling constraints.

The vessel selection problem was thus formulated as a MILP problem.
Firstly, the problem was described mathematically.
Next, attention was focussed on the method of solution.  
There are many available linear programming solvers, both proprietary and open
source.
Many proprietary solvers have free academic licenses.
The XPRESS solver from FICO was familiar to the author from the course module
in linear programming, but the documentation is poor and the licensing system
required connection to university servers which proved unreliable remotely.
The version avaialable through the university also had no python API (one is
avaialble in more recent versions), which was a strong preference for output
data analysis and plotting.

The CPLEX solver from IBM was investigated.  
The quality of the documentation is excellent, and there is a full python API
which also has excellent documentation.

The MILP problem was thus constructed in python and then solved via the CPLEX
python API.
It was apparent that comparitively few lines of the code involved interface
with the API.
With a view to making this research as useful as possible, open-source
alternatives were also investigated.
In the end, the PuLP python library was used as a bridge between problem
generation and problem solution.
PuLP is an open-source python library which acts as an API to several
(MI)LP solvers, both commercial and open source.

\section{Slots}\label{S.slots}

To model the probem as an MILP problem, we must introduce the concept of
\emph{slots}.
Noting that there is a buffer hold vessel for each buffer, it is evident that 
a feasible, but inefficient, solution could involve installing a dedicated,
suitably sized, preparation vessel for each hold vessel.  
Any solution involving more than this number of preparation vessels would not
be optimal.
As a result, we have an upper limit of $N$ on the number of required
preparation vessels.
The model is thus constructed with $P$ \emph{slots}, where

\begin{equation}
    P = N
\end{equation}

and a slot is a notional space which may be occupied by a vessel, or may be
empty.
Note that slots do not have any physical significance, i.e. there is no floor
space assigned to notional slots, only to actual vessels.

\section{Objective Function}\label{S.objfn}

The vessel selection problem may be described as a series of linear constraints.
These constraints are applied to find the optimium value of an objective
function, which we seek to minimise.
The primary objective function is the total cost of vessels.
We find this by summing the vessel costs for all vessels present in slots.
Recall that the vessel data set contains entries for $M$ vessel sizes, each
of which has an associated cost, $c_{m}$.

We now introduce the first decision variable, $\boldsymbol{y}_{mp}$.
This a binary decision variable (matrix) with dimensions $M \times P$.
Note that binary decision variables may only take the values 0 and 1, i.e.
\begin{equation}
    \boldsymbol{y}_{mp} \in \left\{ 0, 1 \right\} \quad \forall m \in M \quad
    \forall p \in P
\end{equation}

The possible states of $\boldsymbol{y}_{mp}$ may be described thus:

\begin{equation}
    \boldsymbol{y}_{mp} =
    \begin{cases}
        1 \implies \text{instance of vessel $m$ in slot $p$}\\
        0 \implies \text{otherwise}
    \end{cases}
\end{equation}

We can now describe the objective function, which gives the objective function
value, $\boldsymbol{Z}$.  The objective is to minimise $\boldsymbol{Z}$.

\begin{equation}
    \boldsymbol{Z} = \sum_{m \in M} \sum_{p \in P} c_m \boldsymbol{y}_{mp}
\end{equation} 

\section{Basic Problem}\label{S.basicprob}

A small number of constraints need to be applied to arrive at the simplest 
variant of the problem.
Additional constraints may then be added to make the model more detailed or
realistic.

\subsection{Buffers Dedicated to Slots}\label{SS.constr1}

The first constraint to be added is the limitation that a buffer must be 
prepared in exactly one slot.
This constraint means that we must preprare each buffer once per cycle
and also that the buffer is always prepared in the same slot -- i.e. slot
selection for every cycle is identical.

We introduce a new binary decision variable, $\boldsymbol{x}_{np}$, which takes
a value of 1 if buffer n is prepared in slot p, and takes a value of 0 
otherwise, i.e.

\begin{equation}
    \boldsymbol{x}_{np} \in \left\{ 0, 1 \right\} \quad \forall n \in N \quad
    \forall p \in P
\end{equation}

The possible states of $\boldsymbol{x}_{np}$ may be described thus:

\begin{equation}
    \boldsymbol{x}_{np} =
    \begin{cases}
        1 \implies \text{buffer $n$ prepared in slot $p$}\\
        0 \implies \text{otherwise}
    \end{cases}
\end{equation}

The following constraint can now be defined:

\begin{equation}
    \sum_{p \in P} \boldsymbol{x}_{np} = 1 \quad \forall n \in N
\end{equation}

\subsection{Vessel Instances Dedicated to Slots}\label{SS.constr2}

The second constraint to be added is the requirement that at most one vessel
may inhabit a given slot.
This is not directly analagous to the first constraint -- it is possible to 
use the same \emph{sized} vessel in many slots, but a maximum of one vessel 
\emph{instance} may inhabit any given slot.
Note that this inequality allows for the possibility of unused slots, i.e. the
number of occupied slots (and hence the number of preparation vessels) may be
less than the number of available slots (and hence the number of buffers).

\begin{equation}
    \sum_{m \in M} \boldsymbol{y}_{mp} \le 1 \quad \forall p \in P
\end{equation}

\subsection{Vessel Capacity}\label{SS.constr3}

The third constraint is the requirement that, if a vessel is in a given slot,
it has an appropriate volume to prepare all buffers assigned to the slot.
There are two facets to the above statement.  
Firstly, we cannot produce buffer volumes greater than the preparation vessel
volume.  
Additionally, vessels have a minimum fill ratio, ususally in the range 
10 - 30 \%.
This ratio is captured as the input parameter $r_{MINFILL}$.
The minimum fill ratio is generally a function of the minimum stir volume of 
the vessel's impeller.

More complicated rules may be applied, such as the ability to make an excess
of buffer to prevent the requirement for adding a smaller vessel, but such
approaches are beyond the scope of this basic model.

Recall that for each vessel size, $m \in M$, we have defined a (maximum) vessel
volume, $V_{m}$. Also, for each buffer, $n \in N$, we have defined the required
volume, $U_{n}$. 

The maximum vessel capacity constraint is:
        
\begin{equation}
    U_{n} \boldsymbol{x}_{np} - \sum_{m \in M} V_{m} \boldsymbol{y}_{mp} \le 0
    \quad \forall n \in N, \quad \forall p \in P
\end{equation}

The minimum vessel capacity constraint is slightly more complex, in that the
\emph{big-M} method must be utilised. The value used for \emph{big-M} is
$V_{MAX}$, where:

\begin{equation}
    V_{MAX} = \text{max} \left( V_{m} \right) \quad \forall m \in M
\end{equation}

The minimum vessel capacity constraint is defined as:

\begin{equation}
    V_{MAX} \boldsymbol{x}_{np} + r_{MINFILL} \sum_{m \in M} V_{m} 
    \boldsymbol{y}_{mp} \le U_{n} + V_{MAX} \quad \forall n \in N, \quad
    \forall p \in P
\end{equation}

\subsection{Hold Procedure Duration}\label{SS.constr4}

The fourth constraint required for a basic model is the limitation that the
total duration of each hold prcedure must not be greater than the cycle time.
If this constraint is not observed, a hold procedure in a given batch may not
have finished before the hold procedure for the next batch is due to start.

\begin{equation}
    \boldsymbol{z}_{n} \le \lambda - \left( \Delta t_{HOLD,PRE} +
    \Delta t_{TRANSFER} + \Delta t_{USE,n} + \Delta t_{HOLD,POST} \right)
    \quad \forall n \in N
\end{equation}

\subsection{Preparation Vessel Utilisation}\label{SS.constr5}

The final constraint required for a basic model is similar to the above.
We wish to ensure that, in a given slot, the sum of the total durations of each
preparation procedure in that slot is not greater than the cycle time.
If this were not the case, for a given slot, there would be insufficient
time to carry out all the preparations assigned to that slot.
Note that at this point, we have not concerned ourselves with \emph{when}
the buffers are required by the process -- indeed, perhaps this information is
not available early in a design project.
To make the model more realistic, we can modify this constraint so that sum of
the total durations mentioned above is not greater than some fraction of the
cycle time, the \emph{maximum utilisation ratio}.
By applying this constraint, we are saying that, in the absence of any detailed
scheduling data, we want to ensure that out preparation vessels
are used less than, e.g. 60\% of the time.

\begin{equation}
    \Delta t_{PREP,TOTAL} \sum_{n \in N} \boldsymbol{x}_{np} \le r_{UTIL} 
    \lambda \quad \forall p \in P
\end{equation}

where

\begin{equation}
    \Delta t_{PREP,TOTAL} = \Delta t_{PREP,PRE} + \Delta t_{TRANSFER} +
    \Delta t_{PREP,POST}  
\end{equation}

The above model may be solved to produce a vessel selection.
The resultant selection would be a rough guide, in the absence of production
scheduling information, of the number and size of vessels required for a 
facility, using the maximum utilisation ratio as a proxy for a schedule.

\section{Preparation Scheduling Constraints}\label{S.prepsched}

For a more accurate appraisal of vessel requirements, more data is required
on scheduling.
Specifically, data are required on the duration of use of each buffer, along
with data on the time of first use of each buffer, relative to some fixed point
in a batch (e.g. batch start).
Given this information, it is possible to constrain the problem so that the
individual preparations are scheduled correctly.
The scheduling constraint may be descibed quite simply:
Ensure that no two preparation operations overlap in time in a given slot.

Since we have a constant preparation duration, $ \Delta t_{PREP,TOTAL} $, this
constraint may be expressed, \emph{for any two distinct buffers that are made
in the same slot}, by the following:

\begin{equation}
    \lvert \left( t_{USE,k} - \boldsymbol{z}_{k} \right) - \left( t_{USE,n} - 
    \boldsymbol{z}_{n} \right) \rvert \le \Delta t_{USE,TOTAL} \quad \forall n 
    \in N, \quad \forall k \in N, k > n
\end{equation}

Note that the range of $ k $ is limited to $ k > n $ to prevent duplication
of constraints.
The above formula is not yet in a format that can be applied in a MILP.
Firstly, it was noted that the constraints only apply to two buffers which
happen to be made in the same slot.
Secondly, absolute value expressions are not valid in linear programming
constraints.
To overcome these issues, several additional constraints and variables must be
introduced.

\subsection{Pairs of Distinct Buffers Prepared in a Particular Slot}\label{SS.constr6}

Firstly, we want to specify a binary variable which indicates if two distinct
buffers are made in the same slot.  
This, in turn requres an additional binary variable which indicates if two
distinct buffers are made in a \emph{particular} slot.
The latter binary variable, $ \boldsymbol{w}_{nkp} $ is defined through a pair
of constraints:

\begin{equation}
    \begin{split}
        \begin{alignedat}{3}
            \boldsymbol{x}_{np} & {}+{} & \boldsymbol{x}_{kp} & {}-{} & 2 
            \boldsymbol{w}_{nkp} & \ge 0\\
            \boldsymbol{x}_{np} & {}+{} & \boldsymbol{x}_{kp} & {}-{} &
            \boldsymbol{w}_{nkp} & \le 1\\
        \end{alignedat}
    \end{split}
    \quad\quad
    \begin{split}
        \forall n \in N, \quad \forall k \in N, k > n
    \end{split}
\end{equation}

A truth table for the above constraints is given below.
In the table below, $\boldsymbol{w}_{nkp}^{\left( 1 \right)}$ refers to the 
first inequality above and $\boldsymbol{w}_{nkp}^{\left( 2 \right)}$ refers to
the second.  Applying both inequalities is equivalent to performing a
logical-and, i.e. 
$\boldsymbol{w}_{nkp} = \boldsymbol{w}_{nkp}^{\left( 1 \right)} \land
\boldsymbol{w}_{nkp}^{\left( 2 \right)}$.

\begin{center}
    \begin{tabular}{c c | c c | c}
        $\boldsymbol{x}_{np}$ & $\boldsymbol{x}_{kp}$ & 
        $\boldsymbol{w}_{nkp}^{\left( 1 \right)}$ &
        $\boldsymbol{w}_{nkp}^{\left( 2 \right)}$ & 
        $\boldsymbol{w}_{nkp} = \boldsymbol{w}_{nkp}^{\left( 1 \right)}
            \land \boldsymbol{w}_{nkp}^{\left( 2 \right)}
        $\\ \hline
        0 & 0 & 0 & $\left\{ 0,1 \right\}$ & 0\\
        0 & 1 & 0 & $\left\{ 0,1 \right\}$ & 0\\
        1 & 0 & 0 & $\left\{ 0,1 \right\}$ & 0\\
        1 & 1 & $\left\{ 0,1 \right\}$ & 1 & 1\\
    \end{tabular}
\end{center}

\subsection{Pairs of Distict Buffers Prepared in the Same Slot}\label{SS.constr7}

Given the above constraint, we can now define a binary variable, 
$ \boldsymbol{v}_{nk} $ which indicates if two distinct buffers are made in the
same slot.
This new varaible is introduced via the following constraint:

\begin{equation}
    \sum_{p \in P} \boldsymbol{w}_{nkp} - \boldsymbol{v}_{nk} \le 0 \quad
    \forall n \in N, \quad \forall k \in N, k > n
\end{equation}

The truth table for the above constraint, for a given $n$ and $k$ is detailed
 below.

\begin{center}
    \begin{tabular}{c c c c | c}
        $\boldsymbol{w}_{nk0}$ & $\boldsymbol{w}_{nk1}$ & $\cdots$
        & $\boldsymbol{w}_{nkP}$ & $\boldsymbol{v}_{nk}$ \\ \hline
        0 & 0 & $\cdots$ & 0 & 0\\
        0 & 0 & $\cdots$ & 1 & 0\\
        $\vdots$ & $\vdots$ & $\ddots$ & $\vdots$ & $\vdots$\\
        1 & 1 & $\cdots$ & 0 & 0\\
        1 & 1 & $\cdots$ & 1 & 1\\
    \end{tabular}
\end{center}

\subsection{Order of Preparation of a Pair of Distinct Buffers}\label{SS.constr8}

Recall that we still cannot apply our scheduling constraint due to the presence
of an absolute value expression in the equation.
The absolute value expression may be though of as representing a pair of 
constraints, e.g.
$ \lvert \alpha - \beta \rvert \ge \gamma $
is essentially shorthand for
$ \alpha - \beta \ge \gamma \quad \lor \quad \beta - \alpha \ge \gamma $. 
We now need to remove the logical-or ($\lor$) from the above pair of
inequalities.
This can be done by using the \emph{big-M} method, whereby a large constant,
$ \mathbb{M} $, is used to force selection of one or other of the constraints
based on the value of an additional binary.
In our case, the absolute value function represents two cases.
In one case, buffer $n$ is prepared before another buffer $k$, and in the
alternate case, buffer $k$ is prepared after buffer $n$.
We thus define a binary, $\boldsymbol{u}_{nk}$, such that
$ \boldsymbol{u}_{nk} = 0 $ if $n$ is prepared before $k$ and
$ \boldsymbol{u}_{nk} = 1 $ if $k$ is prepared before $n$.
In the edge case where the buffers are prepared at precisely the same time,
the binary may take either value.

We are not yet ready to define the constraint which governs the value of
$\boldsymbol{u}_{nk}$.
The reason for this is that it is difficult to define if one event happens
before or after another when they occur repeatedly in a cyclic process.
Recall that for each buffer, the scheduling data consist of a use start time
and a use duration.
From the point of view of the model, we are only concerned with the 
steady-state cyclic case, so we use a modified use start time:

\begin{equation}
    t_{USE,n}^{\prime} = t_{USE,n} \mod \lambda \quad \forall n \in N
\end{equation}

We want to now rigorously define whether an event, $\alpha$, occurs after
another event, $\beta$, iff $ \alpha \mod \lambda > \beta \mod \lambda $.
We are concerned with the timing of our preparation procedures.
Recall that all preparation procedures have the same durations.
Thus, when deciding which of two such procedures occurs first, we can use 
$ t_{USE,n}^{\prime} - \boldsymbol{z}_{n} $ to mark the timing of the
preparation procedure of a given buffer $n$.
Note that this may take a negative value, which must be corrected by adding a
factor of $\lambda$ to bring the vaue back into the single-cycle range, as we
can't use a modulo expression in an MILP constraint.
Another binary variable, $ \boldsymbol{q}_{n} $ is introduced to indicate if
$ t_{USE,n}^{\prime} - \boldsymbol{z}_{n} < 0 $, i.e. 

\begin{equation}
    \boldsymbol{q}_{n} =
    \begin{cases}
        1 \implies t_{USE,n}^{\prime} - \boldsymbol{z}_{n} \le 0\\
        0 \implies t_{USE,n}^{\prime} - \boldsymbol{z}_{n} \ge 0
    \end{cases}
    \quad \forall n \in N
\end{equation}

Note that the value of $ \boldsymbol{q}_{n} $ is undefined if 
$ t_{USE,n}^{\prime} - \boldsymbol{z}_{n} = 0 $.
The above definition of $ \boldsymbol{q}_{n} $ is captured in the following
pair of constraints:

\begin{equation}
    \begin{split}
        \begin{alignedat}{2}
            \boldsymbol{z}_{n} & {}-{} & \lambda \boldsymbol{q}_{n} & \le 
            t_{USE,n}^{\prime}\\
            \boldsymbol{z}_{n} & {}-{} & \lambda \boldsymbol{q}_{n} & \ge 
            t_{USE,n}^{\prime} - \lambda
        \end{alignedat}
    \end{split}
    \quad\quad
    \begin{split}
        \forall n \in N
    \end{split}
\end{equation}


\begin{center}
    \begin{tabular}{c | c}
        $t_{USE,n}^{\prime} - \boldsymbol{z}_{n}$ 
        & $\boldsymbol{q}_{n}$\\ \hline
        <0 & 0\\
        0 & $\left\{ 0, 1 \right\}$\\
        >0 & 1\\
    \end{tabular}
\end{center}

Having incorporated $ \boldsymbol{q}_{n} $, we can now implement the pair of 
constraints which, given two distinct buffers, indicate which is prepared
first.

\begin{equation}
    \begin{split}
        \boldsymbol{z}_{n} - \boldsymbol{z}_{k} + \lambda \boldsymbol{u}_{nk}
        - \lambda \boldsymbol{q}_{n} + \lambda \boldsymbol{q}_{k} &\ge 
        t_{USE,n}^{\prime} - t_{USE,k}^{\prime}\\
        \boldsymbol{z}_{n} - \boldsymbol{z}_{k} + \lambda \boldsymbol{u}_{nk}
        - \lambda \boldsymbol{q}_{n} + \lambda \boldsymbol{q}_{k} &\le 
        t_{USE,n}^{\prime} - t_{USE,k}^{\prime} + \lambda
    \end{split}
    \quad \quad \forall n \in N, \quad \forall k \in N, k > n
\end{equation}

\begin{center}
    \begin{tabular}{c c c | c c | c}
        $\left( t_{USE,k}^{\prime} - \boldsymbol{z}_{k} \right)
            - \left( t_{USE,n}^{\prime} - \boldsymbol{z}_{n} \right)$ 
        & $\boldsymbol{q}_{n}$ & $\boldsymbol{q}_{k}$ 
        & $\boldsymbol{u}_{nk}^{\left( 1 \right)}$ 
        & $\boldsymbol{u}_{nk}^{\left( 2 \right)}$
        & $\boldsymbol{u}_{nk} = \boldsymbol{u}_{nk}^{\left( 1 \right)}
            \land \boldsymbol{u}_{nk}^{\left( 2 \right)}$\\ \hline
        <0 & 0 & 0 & 1 & $\left\{ 0,1 \right\}$& 1\\
        <0 & 0 & 1 & $\left\{ 0,1 \right\}$ & 0 & 0\\
        <0 & 1 & 0 & N/A & $\left\{ 0,1 \right\}$ & N/A\\
        <0 & 1 & 1 & $\left\{ 0,1 \right\}$ & 1 & 1\\
        0 & 0 & 0 & $\left\{ 0,1 \right\}$ & $\left\{ 0,1 \right\}$ 
            & $\left\{ 0,1 \right\}$\\
        0 & 0 & 1 & $\left\{ 0,1 \right\}$ & 0 & 0\\
        0 & 1 & 0 & 1 & $\left\{ 0,1 \right\}$ & 1\\
        0 & 1 & 1 & $\left\{ 0,1 \right\}$ & $\left\{ 0,1 \right\}$
        & $\left\{ 0,1 \right\}$\\
        >0 & 0 & 0 & $\left\{ 0,1 \right\}$ & 0 & 0\\
        >0 & 0 & 1 & $\left\{ 0,1 \right\}$ & N/A & N/A\\
        >0 & 1 & 0 & 1 & $\left\{ 0,1 \right\}$ & 1\\
        >0 & 1 & 1 & $\left\{ 0,1 \right\}$ & 0 & 0\\
    \end{tabular}
\end{center}

The above truth table seems counterintuitive -- check to make sure it's
correct.

\subsection{Preparation Scheduling}\label{SS.constr9}

With the above constraint, we can finally implement the scheduling constraint:

\begin{equation}
    \begin{split}
        \begin{alignedat}{10}
        &\boldsymbol{z}_{n} {}-{} &\boldsymbol{z}_{k} {}+{} &\mathbb{M}
        \boldsymbol{u}_{nk} {}-{} &\mathbb{M} \boldsymbol{v}_{nk} &\ge
        &t_{USE,n}^{\prime} {}-{} &t_{USE,k}^{\prime} {}+{}
        &\Delta &t_{PREP,TOTAL} {}-{} &\mathbb{M}\\
        - &\boldsymbol{z}_{n} {}+{} &\boldsymbol{z}_{k} {}-{} &\mathbb{M}
        \boldsymbol{u}_{nk} {}-{} &\mathbb{M} \boldsymbol{v}_{nk} &\ge
        - &t_{USE,n}^{\prime} {}+{} &t_{USE,k}^{\prime} {}+{}
        &\Delta &t_{PREP,TOTAL} {}-{} 2 &\mathbb{M}
        \end{alignedat}
        \\\forall n \in N, \quad \forall k \in N, k > n
    \end{split}
\end{equation}

where

\begin{equation}
    \mathbb{M} = 2 \lambda
\end{equation}

Truth table:

\begin{center}
    \begin{tabular}{c c | c}
        $\boldsymbol{u}_{nk}$ & $\boldsymbol{v}_{nk}$ 
        & applicable scheduling constraint\\ \hline
        0 & 0 & none\\
        0 & 1 & $\left( t_{USE,k}^{\prime} - \boldsymbol{z}_{k} \right)
            - \left( t_{USE,n}^{\prime} - \boldsymbol{z}_{n} \right)
            \ge \Delta t_{PREP,TOTAL}$\\
        1 & 0 & none\\
        1 & 1 & $\left( t_{USE,n}^{\prime} - \boldsymbol{z}_{n} \right)
            - \left( t_{USE,k}^{\prime} - \boldsymbol{z}_{k} \right)
            \ge \Delta t_{PREP,TOTAL}$\\
    \end{tabular}
\end{center}
% TODO: Truth Tables
